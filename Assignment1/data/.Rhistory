a<-resinvmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-resexpmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-reslogmatrix
interaction<-as.factor(dataset$interaction)
print(fligner.test(a~interaction))
cat("3. Homoscedasticity - non-parametric (fligner)", file = "ZAT6 FC.txt", append = TRUE)
cat("\n\n", file = "ZAT6 FC.txt", append = TRUE)
capture.output(fligner.test(a~interaction), file = "ZAT6 FC.txt", append = TRUE)
# 8. Non-parametric ANOVA (Kruskal-Wallis test)
print(kruskal.test(matrix~dataset$interaction))
# 9. Non-parametrical two-by-two comparisons (Pairwise Wilcoxon rank sum test)
library (reshape2)
#install.packages("reshape2")
(a <- melt(pairwise.wilcox.test(matrix, interaction, p.adjust="none")$p.value))
a.cc  <-  na.omit(a)
a.pvals  <-  a.cc[, 3]
names(a.pvals)  <-  paste(a.cc[, 1], a.cc[, 2], sep="-")
a.pvals
print(pairwise.wilcox.test(matrix, interaction, p.adjust="fdr"))
}
for (i in plant_genes) {
print(i)
#datasets <- excel_sheets("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx") %>% map(~read_xlsx("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx",.))
dataset<- read_excel("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx",
sheet = i, range = "B2:M18", col_types = c("text", "text", "text", "skip", "skip", "skip", "skip", "numeric","skip", "skip", "numeric","numeric"))
dataset <- dataset[-c(9)]
View(dataset)
attach (dataset)
# performing transformations
matrix<-cbind(dataset$`Fold change (normalised)`)
root_segment<-as.factor(dataset$`ROOT SEGMENT`)
treatment<-as.factor(dataset$CONCENTRATION)
regmatrix<-lm(matrix~root_segment*treatment)
resmatrix<-residuals(regmatrix)
sqrtmatrix<-sqrt(matrix)
regsqrtmatrix<-lm(sqrtmatrix~root_segment*treatment)
ressqrtmatrix<-residuals(regsqrtmatrix)
invmatrix<-1/(matrix)
reginvmatrix<-lm(invmatrix~root_segment*treatment)
resinvmatrix<-residuals(reginvmatrix)
expmatrix<-exp(matrix)
regexpmatrix<-lm(expmatrix~root_segment*treatment)
resexpmatrix<-residuals(regexpmatrix)
logmatrix<-log(matrix)
reglogmatrix<-lm(logmatrix~root_segment*treatment)
reslogmatrix<-residuals(reglogmatrix)
# 3. Testing normality of residuals (Shapiro-Wilk test)(if p>0.05 = OK)
print(shapiro.test(resmatrix))
shapiro.test(ressqrtmatrix)
shapiro.test(resinvmatrix)
shapiro.test(resexpmatrix)
print(shapiro.test(reslogmatrix))
# 4. Testing homoscedasticity variances (Bartlett)(if p>0.05 = OK)
# Deze test is gevoelig voor afwijkingen van de normaliteit en kan hierdoor een vals positief resultaat geven.
a<-resmatrix
interaction<-as.factor(dataset$interaction)
print(bartlett.test(a~interaction))
a<-ressqrtmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-resinvmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-resexpmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-reslogmatrix
interaction<-as.factor(dataset$interaction)
print(bartlett.test(a~interaction))
# 5. Parametrical ANOVA (ANOVA)
lm1<-lm(matrix~ root_segment*treatment)
print(anova(lm1))
lm1<-lm(sqrtmatrix~root_segment*treatment)
anova(lm1)
lm1<-lm(invmatrix~ root_segment*treatment)
anova(lm1)
lm1<-lm(expmatrix~ root_segment*treatment)
anova(lm1)
lm1<-lm(logmatrix~ root_segment*treatment)
print(anova(lm1))
# 6. Parametrical two-by-two comparisons (TukeyHSD test)
lm2<-aov(matrix~ root_segment*treatment)
print(TukeyHSD(lm2))
lm2<-aov(sqrtmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(invmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(expmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(logmatrix~ root_segment*treatment)
print(TukeyHSD(lm2))
# 7. Testing homoscedasticity variances (if p>0.05 = OK) via fligner.test
# Deze test is een-niet paramatrisch alternatief voor de barlett test die gevoelig is voor afwijkingen van normaliteit
a<-resmatrix
interaction<-as.factor(dataset$interaction)
print(fligner.test(a~interaction))
a<-ressqrtmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-resinvmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-resexpmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-reslogmatrix
interaction<-as.factor(dataset$interaction)
print(fligner.test(a~interaction))
cat("3. Homoscedasticity - non-parametric (fligner)", file = "ZAT6 FC.txt", append = TRUE)
cat("\n\n", file = "ZAT6 FC.txt", append = TRUE)
capture.output(fligner.test(a~interaction), file = "ZAT6 FC.txt", append = TRUE)
# 8. Non-parametric ANOVA (Kruskal-Wallis test)
print(kruskal.test(matrix~dataset$interaction))
# 9. Non-parametrical two-by-two comparisons (Pairwise Wilcoxon rank sum test)
library (reshape2)
#install.packages("reshape2")
(a <- melt(pairwise.wilcox.test(matrix, interaction, p.adjust="none")$p.value))
a.cc  <-  na.omit(a)
a.pvals  <-  a.cc[, 3]
names(a.pvals)  <-  paste(a.cc[, 1], a.cc[, 2], sep="-")
a.pvals
print(pairwise.wilcox.test(matrix, interaction, p.adjust="fdr"))
}
for (i in plant_genes) {
print(i)
#datasets <- excel_sheets("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx") %>% map(~read_xlsx("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx",.))
dataset<- read_excel("C:/Users/geoff/Downloads/Sample-and-NF-information.xlsx",
sheet = i, range = "B2:M18", col_types = c("text", "text", "text", "skip", "skip", "skip", "skip", "numeric","skip", "skip", "numeric","numeric"))
dataset <- dataset[-c(9),]
View(dataset)
attach (dataset)
# performing transformations
matrix<-cbind(dataset$`Fold change (normalised)`)
root_segment<-as.factor(dataset$`ROOT SEGMENT`)
treatment<-as.factor(dataset$CONCENTRATION)
regmatrix<-lm(matrix~root_segment*treatment)
resmatrix<-residuals(regmatrix)
sqrtmatrix<-sqrt(matrix)
regsqrtmatrix<-lm(sqrtmatrix~root_segment*treatment)
ressqrtmatrix<-residuals(regsqrtmatrix)
invmatrix<-1/(matrix)
reginvmatrix<-lm(invmatrix~root_segment*treatment)
resinvmatrix<-residuals(reginvmatrix)
expmatrix<-exp(matrix)
regexpmatrix<-lm(expmatrix~root_segment*treatment)
resexpmatrix<-residuals(regexpmatrix)
logmatrix<-log(matrix)
reglogmatrix<-lm(logmatrix~root_segment*treatment)
reslogmatrix<-residuals(reglogmatrix)
# 3. Testing normality of residuals (Shapiro-Wilk test)(if p>0.05 = OK)
print(shapiro.test(resmatrix))
shapiro.test(ressqrtmatrix)
shapiro.test(resinvmatrix)
shapiro.test(resexpmatrix)
print(shapiro.test(reslogmatrix))
# 4. Testing homoscedasticity variances (Bartlett)(if p>0.05 = OK)
# Deze test is gevoelig voor afwijkingen van de normaliteit en kan hierdoor een vals positief resultaat geven.
a<-resmatrix
interaction<-as.factor(dataset$interaction)
print(bartlett.test(a~interaction))
a<-ressqrtmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-resinvmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-resexpmatrix
interaction<-as.factor(dataset$interaction)
bartlett.test(a~interaction)
a<-reslogmatrix
interaction<-as.factor(dataset$interaction)
print(bartlett.test(a~interaction))
# 5. Parametrical ANOVA (ANOVA)
lm1<-lm(matrix~ root_segment*treatment)
print(anova(lm1))
lm1<-lm(sqrtmatrix~root_segment*treatment)
anova(lm1)
lm1<-lm(invmatrix~ root_segment*treatment)
anova(lm1)
lm1<-lm(expmatrix~ root_segment*treatment)
anova(lm1)
lm1<-lm(logmatrix~ root_segment*treatment)
print(anova(lm1))
# 6. Parametrical two-by-two comparisons (TukeyHSD test)
lm2<-aov(matrix~ root_segment*treatment)
print(TukeyHSD(lm2))
lm2<-aov(sqrtmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(invmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(expmatrix~ root_segment*treatment)
TukeyHSD(lm2)
lm2<-aov(logmatrix~ root_segment*treatment)
print(TukeyHSD(lm2))
# 7. Testing homoscedasticity variances (if p>0.05 = OK) via fligner.test
# Deze test is een-niet paramatrisch alternatief voor de barlett test die gevoelig is voor afwijkingen van normaliteit
a<-resmatrix
interaction<-as.factor(dataset$interaction)
print(fligner.test(a~interaction))
a<-ressqrtmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-resinvmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-resexpmatrix
interaction<-as.factor(dataset$interaction)
fligner.test(a~interaction)
a<-reslogmatrix
interaction<-as.factor(dataset$interaction)
print(fligner.test(a~interaction))
cat("3. Homoscedasticity - non-parametric (fligner)", file = "ZAT6 FC.txt", append = TRUE)
cat("\n\n", file = "ZAT6 FC.txt", append = TRUE)
capture.output(fligner.test(a~interaction), file = "ZAT6 FC.txt", append = TRUE)
# 8. Non-parametric ANOVA (Kruskal-Wallis test)
print(kruskal.test(matrix~dataset$interaction))
# 9. Non-parametrical two-by-two comparisons (Pairwise Wilcoxon rank sum test)
library (reshape2)
#install.packages("reshape2")
(a <- melt(pairwise.wilcox.test(matrix, interaction, p.adjust="none")$p.value))
a.cc  <-  na.omit(a)
a.pvals  <-  a.cc[, 3]
names(a.pvals)  <-  paste(a.cc[, 1], a.cc[, 2], sep="-")
a.pvals
print(pairwise.wilcox.test(matrix, interaction, p.adjust="fdr"))
}
pnorm(60,75,10)
pnorm(-1.5)
c  <- c(1,2,3,4,5,6)
mean(c)
var(c)
sigmoid = function(x) {
1 / (1 + exp(-x))
}
net = function(w_1,i_1, w_2,i_2,b_1) {
w_1 * i_1 + w_2 * i_2 + b_1 * 1
}
x1 <-(1, 1, 1)
x2 <-(2, −1, −1)
y1<-(3, 0, −1)
weights_neuron <-(0.5,0.4,-0.2,-0.8,-0.7,0.6,-0.5,-0.2,1.3)
y1<-c(3, 0, −1)
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,-0.7,0.6,-0.5,-0.2,1.3)
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,-0.7,0.6,-0.5,-0.2,1.3)
weights_neuron[0]
weights_neuron[1]
weights_neuron[3]
weights_neuron[5]
net_input1 <- net(weights_neuron[3],x1[1],weights_neuron[5],x2[1],weights_neuron[1])
net_input1
x2[1]
net_input2 <- net(weights_neuron[4],x1[1],weights_neuron[6],x2[1],weights_neuron[2])
net_input2
sigmoid1 <- sigmoid(net_input1)
sigmoid2 <- sigmoid(net_input2)
weights_neuron[7]
weights_neuron[8]
weights_neuron[9]
net_output <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
net_output
b <-c()
b <- b + 1
b
b + 1
for (x in 1:10) {
print(x)
}
for (x in 1:3) {
print(x)
}
for (i in 1:3) {
print(i)
}
net_output
for (i in 1:3) {
net_input1 <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2 <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1)
sigmoid2 <- sigmoid(net_input2)
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
}
net_output
library(Metrics)
install.packages('Metrics')
library(Metrics)
result = (rmse(y, net_output))^2
result = (rmse(y1, net_output))^2
result
net_input1
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
}
net_output
net_input1
net_input2
weight1 <-c(),weight2 <-c(),weight3 <-c(),weight4 <-c(),weight5 <-c(),weight6 <-c(),
weight7 <-c(),weight8 <-c(),weight9 <-c()
weight1 <-c(),weight2 <-c(),weight3 <-c(),weight4 <-c(),weight5 <-c(),weight6 <-c()
weight7 <-c(),weight8 <-c(),weight9 <-c()
weight5 <-c();weight6 <-c()
weight7 <-c();weight8 <-c();weight9 <-c()
net_output <-c()
net_input1 <-c()
net_input2 <-c()
weight1 <-c()
weight2 <-c()
weight3 <-c()
weight4 <-c()
weight5 <-c();weight6 <-c()
weight7 <-c();weight8 <-c();weight9 <-c()
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
weight1 <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight1[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))
weight2[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))
weight3[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[1]
weight4[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[1]
weight5[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[2]
weight6[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[2]
weight7[i] <- 2*(net_output[1]-y1[1])
weight8[i] <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight9[i] <- 2*(net_output[1]-y1[1]) *(sigmoid2)
}
weight1
weight2
sum(weight2)
sum(weight2)/3
weights_neuron[8]
sigmoid1 <- sigmoid(net_input1[2])
sigmoid1
(sigmoid1*(1-sigmoid1))
sigmoid = function(x) {
1 / (1 + exp(-x))
}
net = function(w_1,i_1, w_2,i_2,b_1) {
w_1 * i_1 + w_2 * i_2 + b_1 * 1
}
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,-0.7,0.6,-0.5,-0.2,1.3)
net_output <-c()
net_input1 <-c()
net_input2 <-c()
weight1 <-c()
weight2 <-c()
weight3 <-c()
weight4 <-c()
weight5 <-c();weight6 <-c()
weight7 <-c();weight8 <-c();weight9 <-c()
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
weight1 <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight1[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))
weight2[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))
weight3[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[1]
weight4[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[1]
weight5[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[2]
weight6[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[2]
weight7[i] <- 2*(net_output[1]-y1[1])
weight8[i] <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight9[i] <- 2*(net_output[1]-y1[1]) *(sigmoid2)
}
sigmoid = function(x) {
1 / (1 + exp(-x))
}
net = function(w_1,i_1, w_2,i_2,b_1) {
w_1 * i_1 + w_2 * i_2 + b_1 * 1
}
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,-0.7,0.6,-0.5,-0.2,1.3)
net_output <-c()
net_input1 <-c()
net_input2 <-c()
weight1 <-c()
weight2 <-c()
weight3 <-c()
weight4 <-c()
weight5 <-c();weight6 <-c()
weight7 <-c();weight8 <-c();weight9 <-c()
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
weight1[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))
weight2[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))
weight3[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[1]
weight4[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[1]
weight5[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[2]
weight6[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[2]
weight7[i] <- 2*(net_output[1]-y1[1])
weight8[i] <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight9[i] <- 2*(net_output[1]-y1[1]) *(sigmoid2)
}
gradient <-c(mean(weight1),mean(weight2),mean(weight3),mean(weight4),mean(weight5),mean(weight6),mean(weight7),mean(weight8),mean(weight9))
gradient
new_weight <- weights_neuron - gradient
new_weight
weights_neuron
weight1 <-c();weight2 <-c();weight3 <-c();weight4 <-c();weight5 <-c();weight6 <-c();
weight7 <-c();weight8 <-c();weight9 <-c();
sigmoid = function(x) {
1 / (1 + exp(-x))
}
net = function(w_1,i_1, w_2,i_2,b_1) {
w_1 * i_1 + w_2 * i_2 + b_1 * 1
}
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,
-0.7,0.6,-0.5,-0.2,1.3)
net_output <-c();
net_input1 <-c();net_input2 <-c();
weight1 <-c();weight2 <-c();weight3 <-c();weight4 <-c();weight5 <-c();weight6 <-c();
weight7 <-c();weight8 <-c();weight9 <-c();
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
weight1[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))
weight2[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))
weight3[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[1]
weight4[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[1]
weight5[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[2]
weight6[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[2]
weight7[i] <- 2*(net_output[1]-y1[1])
weight8[i] <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight9[i] <- 2*(net_output[1]-y1[1]) *(sigmoid2)
}
library(Metrics)
result = (rmse(y1, net_output))^2
gradient <-c(mean(weight1),mean(weight2),mean(weight3),mean(weight4),mean(weight5),mean(weight6),mean(weight7),mean(weight8),mean(weight9))
new_weight <- weights_neuron - gradient
source('~/datamining/back.R')
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
sigmoid = function(x) {
1 / (1 + exp(-x))
}
net = function(w_1,i_1, w_2,i_2,b_1) {
w_1 * i_1 + w_2 * i_2 + b_1 * 1
}
x1 <-c(1, 1, 1)
x2 <-c(2, −1, −1)
y1<-c(3, 0, −1)
weights_neuron <-c(0.5,0.4,-0.2,-0.8,
-0.7,0.6,-0.5,-0.2,1.3)
net_output <-c();
net_input1 <-c();net_input2 <-c();
weight1 <-c();weight2 <-c();weight3 <-c();weight4 <-c();weight5 <-c();weight6 <-c();
weight7 <-c();weight8 <-c();weight9 <-c();
for (i in 1:3) {
net_input1[i] <- net(weights_neuron[3],x1[i],weights_neuron[5],x2[i],weights_neuron[1])
net_input2[i] <- net(weights_neuron[4],x1[i],weights_neuron[6],x2[i],weights_neuron[2])
#We then squash it using the sigmoid function to get the output
sigmoid1 <- sigmoid(net_input1[i])
sigmoid2 <- sigmoid(net_input2[i])
net_output[i] <-net(weights_neuron[8],sigmoid1,weights_neuron[9],sigmoid2,weights_neuron[7])
weight1[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))
weight2[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))
weight3[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[1]
weight4[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[1]
weight5[i] <-weights_neuron[8]*(sigmoid1*(1-sigmoid1))*x1[2]
weight6[i] <-weights_neuron[9]*(sigmoid2*(1-sigmoid2))*x1[2]
weight7[i] <- 2*(net_output[1]-y1[1])
weight8[i] <- 2*(net_output[1]-y1[1]) *(sigmoid1)
weight9[i] <- 2*(net_output[1]-y1[1]) *(sigmoid2)
}
library(Metrics)
result = (rmse(y1, net_output))^2
gradient <-c(mean(weight1),mean(weight2),mean(weight3),mean(weight4),mean(weight5),mean(weight6),mean(weight7),mean(weight8),mean(weight9))
new_weight <- weights_neuron - gradient
source('~/datamining/back.R')
setwd("C:\Users\geoff\Downloads\data.zip")
setwd("C:/Users/geoff/Downloads/data.zip")
setwd("~/data")
